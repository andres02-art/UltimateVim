1 contiene toda la parte de programacion backend del aplicativo
2 contiene toda la logica de programacion del aplicativo, controlador de modelo de vistas
3 contiene todos los comandos artisan autoejecutables
4 son manejdos por handler en la carpeta exceptions
5 contiene proveedores de librerias de terceros
6 bootstrap es el corazon de laravel
7 contiene los modelos migratorios de la base de datos son usados para relacionar la BD
8 app (archivo donde esta la config del aplicativo), database (archivo donde se encuentra la config a partir de
    laravel), auth (archivo donde se encuentra el kernel y config de validaciones), cache (archivo donde se encuentrar
      consultas almacenadas para ser ejecutadas desde alli), broadcasting (donde se encuentra las configuraciones de testing
        en tiempo real), mail (configuracion de correos), filesystem (configuracion de archivos del sistema).
      9 app, database, mail, auth, broadcasting. el resto no se usan
      10 contiene las migraciones y pruebas a la base de datos
      11 migrations que permite realizar comits, seeder que permite realizar inicializaciones, factories que permite probar la
      12 traductor de laravel a cualquier idioma
      13 son archivos a los que puede acceder de manera publica, no manejar datos sencibles dentro de este
  14 programacion frontend lo transpila vite.js a la carpeta public
16 enrutadores web y api, los otros dos casi no se usan (console, channels)
  17 contiene archivos sencibles que no pueden ser publicos
  18 contiene los casos de prueba del aplicativo
  19 en la carpeta vendor
  20 un comando que usa laravel para su manejo
  21 make:model, make:controller, make:migration, make:job, make:observer, make:policy, make:middleware, make:factory,
  make:seeder, make:rule-make:request, make:provaider
  22 make:model make:migration make:controller
  23 make:observer
  24 make:policy make:rule make:request
  25 make:factory
  26 queue en segundo plano
  27 enum(), unsigned(), index(), restricciones
  28 crea una restriccion donde solo se pueden insertar los valores en un array
  29 con la funcion drop
  30 con php artisan make:migration add_column_to_table_table
  31 debe tener un default o un nullable, para que no conflictue con los registros ya establecidos
  32 es un archivo inicializador de la BD
  33 php artisan migrate --seed
  34 php artisan make:seed TableSeed
35 en el seeder de la base de datos se importa el seed y en la funcion run se indica el seeder a inicializar fun run ()
{
  TableSeed::class;
}
  36 la clase DB es la clase default para manejar seeders
37 table()->insert()
  38 mediante un array tipo diccionario 'column' => 'value'
  39 todos los datos deben ser veridicos, las columnas null y default deben ser correctamente configuradas
  40 bcrypt() es la funcion hash de laravel
  41 factory debe tener el modelo migratorio y un objeto faker que genere datos aleatorios
  42 es un objeto que devuelve datos aleatorios
  43 es un return con un array similar al insert que devuelve datos faker
  44 fun def () {
    return [
      'column1' => 'faker1()';
    'column2' => 'faker2()'
    ]
  }
  45 debe declararse como variable protegida de este modo no es publica
46 debe declararse una funcion configure y dentro de esta retornar $this->afterCreating()
  47 fun configure(){
    return $this->x
  }
  48 $this->afterCreating()
49 Table::factory(num)->create()
  50 se debe tener el modelo migratorio en las clases factories Table::factory(num)->foreingID()->create, se hace
mediante una nueva funcion llamad foreingID()
  51 se debe declarar en la funcion ID con el valor de la llave foranea luego usar $This->state() para insertar la llave
  foranea en la funcion def
  52 en el primer archivo se debe tener: fun configure(){
    return $this->afterCreating(function (){
        Table2::factory(num)->foreingID(MODELS $table1)->create()
        })
  }
y en el segundo archivo se debe tener: fun foreingID(MODELS $table1){
  return $this->state([
      'foreingID' => '$table1->id'
  ])
}
para completar la relacion factory
53 un seeder se ejecuta correctamente importandolo dentro de la funcion call de el mismo en el seeder de BD de este modo
$this->call([ 'seeders',  ])
